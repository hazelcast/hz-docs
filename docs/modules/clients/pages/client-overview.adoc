= Overview
:description: Overview of the main Hazelcast clients and APIs

Hazelcast clients and programming language APIs allow you to extend the benefits of operational in-memory computing to applications in these languages. These clients and APIs are open source and supported by Hazelcast.

This topic discusses the pros and cons of using clients or APIs.

NOTE: Not all features are available in every client. For an overview of what each client offers, 
see the link:https://hazelcast.com/developers/clients/?utm_source=docs-website[clients page].

== Client versus API

Hazelcast provides clients and programming language APIs to interact with Hazelcast clusters and leverage their distributed computing capabilities. The choice between using a client or an API depends on your specific use case, performance requirements, and the programming languages you're using in your project. The following examines the key differences and considerations.

=== Clients (for client/server mode)

Hazelcast clients must be installed locally to communicate with the server.

==== Benefits of using Hazelcast clients

* Language flexibility: Hazelcast offers clients in multiple programming languages, allowing you to use Hazelcast in various environments. 
Clients are available for xref:java.adoc[Java], xref:dotnet.adoc[.NET], xref:python.adoc[Python], xref:cplusplus.adoc[C++], xref:go.adoc[Go], and xref:nodejs.adoc[Node.js]
* Independent scaling: In client/server mode, you can scale the Hazelcast cluster independently from your application. For details, see: https://docs.hazelcast.com/hazelcast/latest/deploy/choosing-a-deployment-option[Choosing an Application Topology]
* Polyglot applications: Client/server mode allows you to write polyglot applications that can all connect to the same cache cluster
* Decoupling application from data: The application and cached data are separated, which can be beneficial for management and security purposes

==== Disadvantages

* Higher latency: As detailed in https://docs.hazelcast.com/hazelcast/latest/deploy/choosing-a-deployment-option[Choosing an Application Topology], client/server mode has higher latency compared to embedded mode because clients need to make network requests to read from or write to the cache
* More complex setup: Client/server mode requires setting up and managing a separate Hazelcast cluster, which can be more complex than embedding Hazelcast directly in your application

==== Maximum number of client connections per member

The maximum recommended number of clients per member is 100.
By default, members have `core count * 20` threads that handle all the requests.
For example, if a member has 4 cores, it will have 80 threads available to handle requests.

==== Serialization in client/server mode

In xref:deploy:choosing-a-deployment-option.adoc[client/server topologies], you can serialize your data
on the client side before sending it to a member. For example, you can serialize data in
JSON and add it to a map. This option is useful if you plan on using Hazelcast to store your
data in binary. The serialization can be handled on the client-side without the members needing to know how to do so.

For details about why you need to serialize data and the options for doing so, see xref:serialization:serialization.adoc[Serialization].

=== APIs (for embedded mode)

If you do not want to use a client to configure the cluster, you can use APIs to configure Hazelcast in embedded mode, where Hazelcast members run in the same Java process as your application. 

APIs are server-side and do not require to be installed. Instead, you simply enable the API on the cluster, and this allows you to be serverless.

#AUTHORS NOTE: It was decided to put the memcache client under the APIs, however doesn't this client still need to be installed? If so, stating that it doesn't need to be installed isn't correct for memcache. Either we need to note this or consider moving memcache under clients again? TBC# 

==== Benefits of using APIs

* Lower latency: For data kept in the embedded member, embedded mode offers faster data access because applications don't need to send requests to the cache cluster over the network
* Simplicity: For Java applications, embedded mode is simpler to set up and use, because you only need to add the Hazelcast JAR to your classpath

==== Disadvantages

* Permissions (such as for IMap read/write) cannot be enforced so the embedded member has access to everything
* Limited to Java: Embedded mode is only available for Java applications, limiting its use in other programming environments
* Coupled scaling: In embedded mode, the application and the cluster must be scaled together, which may not be ideal for all use cases
* Less flexibility: Each instance of your application starts a Hazelcast member, which may lead to unnecessary cluster members if you don't need them. 
However, you can avoid this by creating a member only when necessary



NOTE: Hazelcast offers a Near Cache feature for clients which can help mitigate some of the latency issues in client/server mode by storing frequently used data in the client's local memory.

== Next steps

For detailed information and code samples for each client, see:

* xref:java.adoc[Java]
* xref:dotnet.adoc[.NET]
* xref:python.adoc[Python]
* xref:cplusplus.adoc[C++]
* xref:go.adoc[Go]
* xref:nodejs.adoc[Node.js]

For details about using the Memcache protocol to communicate directly with a Hazelcast cluster, see xref:memcache.adoc[Memcache].
For information about using the REST API for simple operations, see: xref:rest.adoc[REST]
