= CPMap Purge
:page-aliases: cpmap-purge.adoc

== Overview

Starting with *Hazelcast 5.7*, Hazelcast supports purging entries
from `CPMap`s via `CPDataStructureManagementService`. A `CPMap` must
be explicitly enrolled into purge semantics using configuration.
By default, a `CPMap` is not configured to support purge semantics.

The purge operation removes entries that are *older than a specified duration*.
It is intended for controlled cleanup of long-lived `CPMap`s.

== License Requirement

The `CPMap` purge management API (`CPDataStructureManagementService`)
requires a license that includes the `ADVANCED_CP` feature.

Without this license, purge operations fail with
`UnsupportedOperationException`.

== API

[source,java]
----
CompletableFuture<BiTuple<Integer, Integer>> purgeCPMap(String mapName, Duration age);
----

=== Parameters

[cols="1,3",options="header"]
|===
|Parameter |Description
|`mapName` |Name of the CPMap
|`age` |Entries older than `now - age` are eligible for purge
|===

=== Return Value

Returns a `CompletableFuture` that completes with a `BiTuple`:

* **first** – number of entries purged
* **second** – the greatest remaining purge-eligible timestamp, or `-1` if none exist

### Usage Example

The following example purges entries older than 5 days from a `CPMap`:

[source,java]
----
HazelcastInstance hzMemberInstance = Hazelcast.newHazelcastInstance();

String MAP = "my-cp-map";

CompletableFuture<BiTuple<Integer, Integer>> future =
hzMemberInstance.getCPSubsystem()
.getCPDataStructureManagementService()
.purgeCPMap(MAP, Duration.ofDays(5));

future.thenAccept(result -> {
int purgedEntryCount = result.element1();
int greatestRemainingEligibleTimestamp = result.element2();

System.out.println("Purged entries: " + purgedEntryCount);
System.out.println("Greatest remaining eligible timestamp: "
        + greatestRemainingEligibleTimestamp);

});
----

The returned `CompletableFuture` completes when the purge operation
is committed to the CP group.

The result contains:

* **element1** – number of entries removed
* **element2** – the greatest remaining purge-eligible timestamp, or `-1` if none exist

## Configuration Requirements

Purging must be enabled explicitly for each `CPMap`.
By default, purge support is disabled.

If purge is not enabled for a given `CPMap`, invoking
`purgeCPMap()` results in an `UnsupportedOperationException`.

---

### Configuring via XML

[source,xml]
<cp-subsystem>
    ...
    <maps>
        <map>
            <name>myCpMapName</name>
            <purge-enabled>true</purge-enabled>
        </map>
    </maps>
    ...
</cp-subsystem>

### Configuring via YAML

[source,yaml]
  cp-subsystem:
   ...
    maps:
      myCpMapName:
        purge-enabled: true

### Configuring Programmatically

[source,java]
----
Config config = new Config();
CPSubsystemConfig cpSubsystemConfig = config.getCPSubsystemConfig();

CPMapConfig cpMapConfig = new CPMapConfig("my-cp-map-name");
cpMapConfig.setPurgeEnabled(true);

----

*** The configuration must be applied before the cluster starts.
Changing purge settings at runtime is not supported.

== Preconditions and Exceptions

[cols="2,2",options="header"]
|===
|Condition |Result
|Cluster version < 5.7 |`UnsupportedOperationException`
|Purge not enabled |`UnsupportedOperationException`
|No CP group exists |`IllegalArgumentException`
|`mapName` or `age` is `null` |`NullPointerException`
|===

CP groups are created lazily. If a CPMap has never been accessed, purge fails.

== Semantics

* Entries are evaluated by *creation or last update timestamp*
* Entries newer than the specified age are retained
* Purge is linearizable with respect to other `CPMap` operations
* Purge does not run automatically or in the background

=== Timestamp and Clock Semantics

Each `CPMap` operation is assigned a timestamp by the current CP group leader.
Purge decisions rely on these leader-assigned timestamps.

Clock considerations:

* A monotonic clock is recommended on CP members
* Backward clock movement may delay purging
* Clock drift affects purge timing only
* CP safety and correctness are not impacted

== Usage Considerations

=== Small or Zero Durations

Using very small durations (including `Duration.ZERO`) may purge most or all
entries. Applications should validate parameters before invocation.

== Metrics and Observability

Hazelcast exposes purge metrics through Management Center and external monitoring
systems (for example, Prometheus and Grafana).

Monitoring is recommended for large `CPMap`s or frequent purge usage.

Here is the updated **Metrics and Observability** section with explanations of the purge-related metrics included.

You can replace the existing section with the following:

---

## Metrics and Observability

Hazelcast exposes purge metrics through Management Center and external monitoring
systems (for example, Prometheus and Grafana).

Monitoring is strongly recommended for large `CPMap`s or when purge is invoked
frequently, since purge is a state-mutating Raft operation.

The following metrics are available for `CPMap` purge:

### `pendingPurgeCount`
Current number of purge-able entries.

### `lastPurgedCount`
Number of entries removed during the most recently completed purge operation.

### `totalPurgedCount`
Cumulative number of entries removed since the node started.

### `lastPurgeDurationNanos`
Duration (in nanoseconds) of the most recently completed purge.

### `maxPurgeDurationNanos`
Maximum observed purge duration (in nanoseconds) since node startup.

== Large CPMaps and Operational Impact

Purge is a *state-mutating Raft operation* and generates Raft log entries.
Long-running purges may delay heartbeat processing and increase the likelihood of
leader elections if Raft timeouts are aggressive.

== Best Practices

* Enable purge only where needed
* Run purge during low cluster activity
* Monitor purge duration and leader changes
* Use conservative Raft election timeouts for large CP state

== Summary

[cols="2,2",options="header"]
|===
|Aspect |Description
|Introduced in |Hazelcast 5.7
|Enabled by default |No
|Invocation |Manual
|Consistency |Linearizable
|Asynchronous |Yes
|License |ADVANCED_CP required
|===
