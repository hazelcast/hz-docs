= Choose an application topology
:description: Hazelcast offers two topologies: embedded in a Java application or client/server.
:page-aliases: ROOT:topologies.adoc
:url-cloud-signup: https://cloud.hazelcast.com/sign-in?utm_source=docs-website

You can deploy Hazelcast in two topologies, depending on where you want the Hazelcast members to run:

* *Embedded mode*: Hazelcast members run in the same Java process as your application.
* *Client/server mode*: Hazelcast members run remotely outside your application, allowing you to manage and scale them independently. You can connect to them through any of the xref:clients:client-overview.adoc[supported clients].

TIP: If you don't want to deploy your own self-managed cluster, try link:{url-cloud-signup}[Hazelcast {hazelcast-cloud}].

== Embedded mode

Hazelcast is written in Java, which means you can integrate it as a library in your Java application. This topology is called _embedded_ mode.

All you need to do is add the Hazelcast JAR file to your application's classpath and start a member with the Java API. All the benefits of Hazelcast are then available inside the application.

// image::ROOT:single-embedded.svg[A single Hazelcast member is embedded in a Java application,200]

In this mode, each instance of your application starts a Hazelcast member, and members automatically form a cluster. To interact with the cluster, you use a local member in your application.

// image::ROOT:multi-embedded.svg[A cluster of Hazelcast members are embedded in Java applications,600]

The main advantage of embedded mode is that all your Java classes are visible to Hazelcast. This way, you don't need to add classes to your members for tasks such as entry processing or submitting jobs. You may also experience lower latency, although passing data between separate members is still subject to network latency.

xref:getting-started:get-started-java.adoc[Get started with Hazelcast embedded].

== Client/server mode

In client/server mode, the Hazelcast members are independent of your application, which means that they can be scaled independently. To interact with the cluster, you use one of the available clients.

// image::ROOT:client-server-pc-mobile.svg[Client/Server Mode,600]

Hazelcast provides the following clients:

* xref:clients:java.adoc[Java]
* xref:clients:dotnet.adoc[.NET]
* xref:clients:python.adoc[Python]
* xref:clients:cplusplus.adoc[{cpp}]
* xref:clients:go.adoc[Go]
* xref:clients:nodejs.adoc[Node.js]

Client/server mode provides more predictable and reliable
performance, easier identification of problem causes and better scalability.
When you need to scale in this mode, just add more Hazelcast members. You
can address client and server scalability separately.

Client/server mode also provides higher availability. If there are any issues in running either
your application or Hazelcast members, the issue and any potential failure is isolated from the rest of the application and members.

Get started with client/server:

- xref:getting-started:get-started-docker.adoc[Docker]
- xref:getting-started:get-started-cli.adoc[CLI]
- xref:getting-started:get-started-binary.adoc[Binary]