= About the clients and APIs
:description: Overview of the main Hazelcast clients and APIs

Hazelcast clients and programming language APIs allow you to extend the benefits of operational in-memory computing to applications in these languages. These clients and APIs are open source and supported by Hazelcast.

NOTE: Not all features are available in every client. For an overview of what each client offers, 
see the link:https://hazelcast.com/developers/clients/?utm_source=docs-website[clients page].

== Maximum number of client connections per member

The maximum recommended number of clients per member is 100.
By default, members have `core count * 20` threads that handle all the requests.
For example, if a member has 4 cores, it will have 80 threads available to handle requests.

== Serialization in client/server mode

In xref:deploy:choosing-a-deployment-option.adoc[client/server topologies], you can serialize your data
on the client side before sending it to a member. For example, you can serialize data in
JSON and add it to a map. This option is useful if you plan on using Hazelcast to store your
data in binary. Clients can handle serialization without the members needing to know how to do so.

For details about why you need to serialize data and the options for doing so, see xref:serialization:serialization.adoc[Serialization].

== Client versus API

Hazelcast provides clients and programming language APIs to interact with Hazelcast clusters and leverage their distributed computing capabilities. The choice between using a client or an API depends on your specific use case, performance requirements, and the programming languages you're using in your project. The following examines the key differences and considerations.

=== Clients (for client/server mode)

Hazelcast clients must be installed locally to communicate with the server.

==== Benefits of using Hazelcast clients

* Language flexibility: Hazelcast offers clients in multiple programming languages, allowing you to use Hazelcast in various environments. As detailed in the https://docs.hazelcast.com/hazelcast/latest/clients/hazelcast-clients[Hazelcast Clients documentation], clients are available for Java, .NET, Python, C++, Go, Node.js, and Memcache
* Independent scaling: In client/server mode, you can scale the Hazelcast cluster independently from your application. For details, see: https://docs.hazelcast.com/hazelcast/latest/deploy/choosing-a-deployment-option[Choosing an Application Topology]
* Polyglot applications: Client/server mode allows you to write polyglot applications that can all connect to the same cache cluster
* Separation of data: The application and cached data are separated, which can be beneficial for management and security purposes

==== Disadvantages

* Higher latency: As detailed in https://docs.hazelcast.com/hazelcast/latest/deploy/choosing-a-deployment-option[Choosing an Application Topology], client/server mode has higher latency compared to embedded mode because clients need to make network requests to read from or write to the cache
* More complex setup: Client/server mode requires setting up and managing a separate Hazelcast cluster, which can be more complex than embedding Hazelcast directly in your application

=== APIs (for embedded mode)

APIs are server-side and do not require to be installed. Instead, you simply enable the API on the cluster, and this allows you to be serverless.

==== Benefits of using APIs

* Lower latency: Embedded mode offers faster data access because applications don't need to send requests to the cache cluster over the network
* Simplicity: For Java applications, embedded mode is simpler to set up and use, because you only need to add the Hazelcast JAR to your classpath

==== Disadvantages

* Limited to Java: Embedded mode is only available for Java applications, limiting its use in other programming environments
* Coupled scaling: In embedded mode, the application and the cluster must be scaled together, which may not be ideal for all use cases
* Less flexibility: Each instance of your application starts a Hazelcast member, which may lead to unnecessary cluster members if you don't need them

NOTE: Hazelcast offers a Near Cache feature for clients which can help mitigate some of the latency issues in client/server mode by storing frequently used data in the client's local memory.

=== Java: embedded or standalone?

If you are a Java developer, you can choose to embed Java or use the standalone Java client. The decision will depend on your specific use case, scalability requirements, and the features you require. The pros and cons of each method are listed below.

For information about the features and Enterprise Edition capabilities, see: https://docs.hazelcast.com/hazelcast/latest/clients/java[Java Client].

==== Embedded Java Client

Benefits of embedded:

* Simplicity: The embedded client is bundled in the standard Hazelcast package, making it easy to set up and use
* Full feature parity: It has access to all Hazelcast features and Enterprise Edition capabilities 
* Data locality: In embedded topology, the application is close to the data, supporting better data locality. For more information, see: https://docs.hazelcast.com/hazelcast/latest/deploy/choosing-a-deployment-option[Choosing an Application Topology]

Disadvantages:

* Scaling limitations: The application and cluster must be scaled together, which may not be ideal for all use cases. See: https://docs.hazelcast.com/hazelcast/latest/deploy/choosing-a-deployment-option[Choosing an Application Topology]
* Resource sharing: The Hazelcast instance shares resources with the application, which might impact performance in some scenarios

==== Standalone Java Client

Benefits of the standalone client:

* Independent scaling: You can scale the cluster independently of your application, which is beneficial for scenarios with multiple applications sharing the same data. See:  https://docs.hazelcast.com/hazelcast/latest/deploy/choosing-a-deployment-option[Choosing an Application Topology].
* Resource isolation: The client runs separately from the cluster, allowing for better resource management
* Lightweight: It's designed to be a standalone or lightweight Java client

Disadvantages:

* Beta status: The standalone client is currently in beta and not recommended for production environments
* Limited feature parity: It doesn't have full feature parity with the embedded Java client yet
* Some limitations: Certain features like MultiMap and Set are not supported data structures in the standalone client

== Next steps

For detailed information and code samples for each client, see:

* xref:java.adoc[Java]
* xref:dotnet.adoc[.NET]
* xref:python.adoc[Python]
* xref:cplusplus.adoc[C++]
* xref:go.adoc[Go]
* xref:nodejs.adoc[Node.js]
* xref:memcache.adoc[Memcache]