= Overview
:description: Hazelcast clients and programming language APIs allow you to extend the benefits of operational in-memory computing to applications in these languages.

{description}

== Client or API?

Hazelcast provides clients and programming language APIs to interact with Hazelcast clusters and leverage their distributed computing capabilities. The choice between using a client or an API depends on your use case, performance requirements, and the programming languages you're using in your project.

*Clients* refer to the Hazelcast _libraries_ used to connect to a Hazelcast cluster and exchange data. Clients use a xref:clients:client-protocol.adoc[binary protocol] for communication with the cluster and encode the data in various formats such as Compact, JSON, etc. Clients are available in various programming languages.

*APIs* are the _interfaces_ with the Hazelcast platform. These do not require the use of specific libraries to connect and are generally text based â€” for example, the REST interface.

=== Clients

Hazelcast clients must be installed locally to communicate with the server.

==== Benefits

* Language flexibility: Hazelcast offers clients in multiple programming languages, allowing you to use Hazelcast in various environments. 
Clients are available for xref:java.adoc[Java], xref:dotnet.adoc[.NET], xref:python.adoc[Python], xref:cplusplus.adoc[{cpp}], xref:go.adoc[Go], and xref:nodejs.adoc[Node.js].
* Independent scaling: in client/server mode, you can scale the Hazelcast cluster independently from your application. For details, see: xref:deploy:choosing-a-deployment-option.adoc[Choosing an application topology].
* Polyglot applications: client/server mode allows you to write polyglot applications that can all connect to the same cache cluster.
* Decoupling application from data: the application and cached data are separated, which can be beneficial for management and security purposes.

==== Disadvantages

* More complex setup: client/server mode requires setting up and managing a separate Hazelcast cluster, which can be more complex than embedding Hazelcast directly in your application.

==== Maximum number of client connections per member

The maximum recommended number of clients per member is 100.
Members use different executors, each with a different thread count, for handling different types of client message tasks:

* Query tasks: `core count` threads.
* Blocking tasks: `core count * 20` threads.
* All other tasks: `core count` threads.

These values, as well as each member's xref:cluster-performance:threading.adoc#io-threading[I/O Thread] counts, need to be taken into consideration when determining the appropriate client connection limits for clusters.

==== Serialization in client/server mode

In xref:deploy:choosing-a-deployment-option.adoc[client/server topologies], you can serialize your data
on the client side before sending it to a member. For example, you can serialize data in
Kryo and add it to a map. This is useful if you want to store your
data in binary. The serialization can be handled on the client side without the members needing to know how to do so.

For details about why you need to serialize data and the options for doing so, see xref:serialization:serialization.adoc[Serialization].

=== APIs

If you do not want to use a client, you can use APIs to configure Hazelcast in embedded mode, where Hazelcast members run in the same Java process as your application. 

APIs are server side and do not require to be installed. Instead, you simply enable the API on the cluster, and this allows you to be serverless.

==== Benefits

* Lower latency: for data kept in the embedded member, embedded mode offers faster data access because applications do not need to send requests to the cache cluster over the network.
* Simplicity: for Java applications, embedded mode is simpler to set up and use, because you only need to add the Hazelcast JAR to your classpath.

==== Disadvantages

* Permissions (such as for IMap read/write) cannot be enforced so the embedded member has access to everything.
* Limited to Java: embedded mode is only available for Java applications.
* Coupled scaling: in embedded mode, the application and the cluster must be scaled together, which is not suitable for all use cases.
* Less flexibility: Hazelcast members scale with your application instances, which may be inefficient.

TIP: Hazelcast offers a xref:clients:java.adoc#configuring-client-near-cache[Near Cache] feature for clients that can reduce latency in client/server mode by storing frequently used data in the client's local memory.

== Choose a client

Hazelcast's Java client provides comprehensive support for Hazelcast features. Other clients provide more limited support. The following tables list each client's support for Hazelcast features.

.Stream processing
[%collapsible]
====
Applies to Java and Python Jet jobs only.

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Pipeline API
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|===
====

.Data structures
[%collapsible]
====
Hazelcast offers distributed implementations of many common data structures. For each of the client languages, Hazelcast mimics the natural interface of the structure as closely as possible. xref:data-structures:distributed-data-structures.adoc[Learn more].

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Map
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Queue
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Set
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|List
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|MultiMap
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Replicated Map
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Ringbuffer
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Topic
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]

|Reliable Topic
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]

|Jcache
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Cardinality Estimator
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|===
====

.Concurrency primitives
[%collapsible]
====
Data structures in the CP subsystem always maintain linearizability and prefer consistency over availability during network partitions. These data structures are CP with respect to the CAP theorem. xref:cp-subsystem:cp-subsystem.adoc#cp-data-structures[Learn more].

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Semaphore
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]

|Fenced Lock
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]

|AtomicLong
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|AtomicReference
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|CountDownLatch
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]

|CRDT PN Counter
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Flake ID Generator
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|===
====

.Distributed processing
[%collapsible]
====
Distributed processing is the process of running computational tasks on different cluster members. xref:computing:distributed-computing.adoc[Learn more]. 

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Distributed Executor Service
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Entry Processor
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|===
====

.Transactions
[%collapsible]
====
You create a `TransactionContext` object to begin, commit and rollback a transaction. You can obtain transaction-aware instances of queues, maps, sets, lists and multimaps via `TransactionContext`, work with them and commit or roll back in one shot. xref:transactions:creating-a-transaction-interface.adoc[Learn more].

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|TxnMap
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|TxnMultiMap
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|TxnQueue
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|TxnList
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|TxnSet
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|===
====

.Query
[%collapsible]
====
You can use SQL to run optimized distributed queries on the keys and values of maps in a local cluster. xref:sql:querying-maps-sql.adoc[Learn more].

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|SQL
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|SQL Query Re-Submission
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Query (Predicates)
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Paging predicate
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]

|Partition predicate
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Built-in Predicates
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Continuous Query Caching
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Listener with predicate
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Projections
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Aggregations
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|===
====

.Near Cache
[%collapsible]
====
Near Cache is highly recommended for data structures that are mostly read. xref:cluster-performance:near-cache.adoc[Learn more].

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Near Cache support
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|HD Memory
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Preload cache from last used
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Eventual Consistency Control
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|===
====

.Configuration
[%collapsible]
====
You can configure a Hazelcast cluster or client using either static or dynamic configuration. xref:configuration:understanding-configuration.adoc[Learn more].

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Declarative Configuration (XML/JSON/YAML)
|icon:circle-check[size=lg,role=success] (XML/YAML)
|icon:circle-check[size=lg,role=success] (JSON)
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success] (Dictionary objects as config)
|icon:circle-check[size=lg,role=success] (JSON objects as config)
|icon:circle-check[size=lg,role=success] (JSON/YAML/TOML)

|Programmatic Configuration
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Client Configuration Import
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Fail Fast on Invalid Configuration
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Dynamic Configuration
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|===
====

.Security
[%collapsible]
====
These features allow you to perform security activities, such as intercepting socket connections and remote operations executed by the clients, encrypting the communications between the members at socket level and using SSL socket communication. xref:security:overview.adoc[Learn more].

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|SSL Support
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|XA Transactions
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Mutual Authentication
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Authorization
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Custom Authentication Modules
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]

|Token-based credentials
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]

|Kerberos authentication
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|===
====

.Cloud
[%collapsible]
====
Deploy a Hazelcast cluster in cloud environments including Hazelcast Cloud, Amazon Web Services, Google Cloud Platform, and Azure. xref:deploy:deploying-in-cloud.adoc[Learn more].

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Hazelcast Cloud
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Kubernetes
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|AWS
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Azure
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Google Cloud Platform
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Pivotal Cloud Foundry
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Docker
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Apache jclouds
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Consul
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|etcd
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Eureka
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Heroku
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Zookeeper
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|===
====

.Networking
[%collapsible]
====

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Unisocket client
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Smart client
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|===
====

.Event listeners
[%collapsible]
====
You can register for Hazelcast entry events so you are notified when those events occur. xref:events:distributed-events.adoc[Learn more]. 

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Lifecycle listener
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Event listeners
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Sub-listener interfaces for map listener
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|===
====

.Monitoring
[%collapsible]
====
Hazelcast offers an extended set of diagnostics plugins for both Hazelcast members and clients. xref:maintain-cluster:monitoring.adoc#diagnostics[Learn more].

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Diagnostics
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Client-side statistics
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Client Near Cache stats
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]

|Client runtime stats
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Client operating systems stats
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|===
====

.Serialization
[%collapsible]
====
For data to be sent over a network between cluster members and/or clients, it needs to be serialized into raw bytes. Hazelcast supports several serialization options depending on what you plan on doing with your data. xref:serialization:serialization.adoc[Learn more].

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Compact serialization
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Portable serialization
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|IdentifiedDataSerializable
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|JSON (HazelcastJsonValue)
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|DataSerializable
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]

|Custom serializers
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Global serializers
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|===
====

.Client connectivity
[%collapsible]
====
By default, members allow connections from any Hazelcast client. So, any client with access to a member can connect to the cluster and use its resources. xref:getting-started:authenticate-client-tutorial.adoc[Learn more].

[cols="<40%,^10%,^10%,^10%,^10%,^10%,^10%", options="header"]
|===
|[align=left]*Feature*|[align=center]*Java*|[align=center]*.NET*|[align=center]*C++*|[align=center]*Python*|[align=center]*Node.js*|[align=center]*Go*

|Connection strategy
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Connection retry
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]

|Blue/green deployments and disaster recovery
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-xmark[size=lg,role=error]
|icon:circle-check[size=lg,role=success]
|icon:circle-check[size=lg,role=success]
|===
====

For detailed information and code samples for each client, see:

* xref:java.adoc[Java]
* xref:dotnet.adoc[.NET]
* xref:python.adoc[Python]
* xref:cplusplus.adoc[{cpp}]
* xref:go.adoc[Go]
* xref:nodejs.adoc[Node.js]

== Next steps

* To get started with a Hazelcast client, see the client tutorials in xref:clients:hazelcast-clients.adoc[Get started with a Hazelcast Client].

* For details about using Memcache to communicate directly with a Hazelcast cluster, see xref:memcache.adoc[Memcache].

* For information about using the REST API for simple operations, see: xref:rest.adoc[REST].